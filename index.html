<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cinematic Bible Story Generator</title>
<style>
    body { margin: 0; overflow: hidden; background: black; color: white; font-family: sans-serif; }
    #inputBox {
        position: fixed;
        top: 10px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 8px;
        z-index: 2;
        text-align: center;
    }
    textarea { width: 400px; height: 80px; }
    button { padding: 6px 12px; margin-top: 6px; margin-right: 4px; cursor: pointer; }
</style>
</head>
<body>

<div id="inputBox">
    <textarea id="story" placeholder="Enter Bible story text here..."></textarea><br>
    <button onclick="startStory()">Play Cinematic</button>
    <button onclick="downloadScreenshot()">Download Image</button>
    <button onclick="startRecording()">Start Recording</button>
    <button onclick="stopRecording()">Stop & Download Video</button>
</div>

<!-- Three.js core -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>

<!-- Extras for text -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/geometries/TextGeometry.js"></script>

<!-- Postprocessing -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/postprocessing/BokehPass.js"></script>

<script>
let scene, camera, renderer, composer, textMesh, backgroundMesh;
let clock = new THREE.Clock();
let fadeInOpacity = 0;
let recorder, recordedChunks = [];

init();

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 15);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Moving background plane
    const loader = new THREE.TextureLoader();
    loader.load("https://i.ibb.co/XD1YgH3/desert-sky.jpg", texture => {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 1);
        const bgGeo = new THREE.PlaneGeometry(40, 20);
        const bgMat = new THREE.MeshBasicMaterial({ map: texture });
        backgroundMesh = new THREE.Mesh(bgGeo, bgMat);
        backgroundMesh.position.z = -30;
        scene.add(backgroundMesh);
    });

    // Light
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7);
    scene.add(light);

    // Postprocessing
    composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.2, 0.6, 0.9
    );
    composer.addPass(bloomPass);

    const bokehPass = new THREE.BokehPass(scene, camera, {
        focus: 10.0,
        aperture: 0.00015,
        maxblur: 0.01,
        width: window.innerWidth,
        height: window.innerHeight
    });
    composer.addPass(bokehPass);

    window.addEventListener("resize", onWindowResize);
    animate();
}

function startStory() {
    if (textMesh) scene.remove(textMesh);

    fadeInOpacity = 0; // reset fade

    const storyText = document.getElementById("story").value || 
        "In the days of King Ahab, Elijah stood before him...";
    const fontLoader = new THREE.FontLoader();
    fontLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", font => {
        const textGeo = new THREE.TextGeometry(storyText, {
            font: font,
            size: 0.6,
            height: 0.05,
            curveSegments: 12
        });
        const textMat = new THREE.MeshStandardMaterial({ 
            color: 0xffcc66, 
            emissive: 0x442200, 
            transparent: true, 
            opacity: 0 
        });
        textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.position.set(-10, 0, 0);
        scene.add(textMesh);
    });
}

// Screenshot download
function downloadScreenshot() {
    const link = document.createElement('a');
    link.download = 'cinematic_story.png';
    link.href = renderer.domElement.toDataURL('image/png');
    link.click();
}

// Video recording
function startRecording() {
    recordedChunks = [];
    const stream = renderer.domElement.captureStream(30); // 30 FPS
    recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

    recorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
    };

    recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'cinematic_story.webm';
        a.click();
        URL.revokeObjectURL(url);
    };

    recorder.start();
    console.log('Recording started...');
}

function stopRecording() {
    if (recorder && recorder.state !== 'inactive') {
        recorder.stop();
        console.log('Recording stopped, saving file...');
    }
}

function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    // Animate background slowly
    if (backgroundMesh && backgroundMesh.material.map) {
        backgroundMesh.material.map.offset.x += delta * 0.005;
    }

    // Camera cinematic pan
    camera.position.x = Math.sin(Date.now() * 0.00015) * 2;
    camera.position.y = Math.sin(Date.now() * 0.0001) * 0.5;
    camera.lookAt(0, 0, 0);

    // Animate text
    if (textMesh) {
        if (fadeInOpacity < 1) {
            fadeInOpacity += delta * 0.3;
            textMesh.material.opacity = Math.min(fadeInOpacity, 1);
        }
        textMesh.position.x += delta * 0.5;
        textMesh.rotation.y = Math.sin(Date.now() * 0.0005) * 0.1;
    }

    composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
